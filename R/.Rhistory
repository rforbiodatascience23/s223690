#annotation_row = annotation_row_4,
cluster_rows = TRUE,
cluster_cols = TRUE,
main = "Heatmap z-score od DE genes",
breaks = breaks,
color = viridis(10),
fontsize_row = 8,
show_colnames = FALSE,
border_color = "NA",
)
dev.off()
# Chunk 1
library(pheatmap)
library(viridis)
# Chunk 2: Load the data from 02_clean.qmd
de_genes <- read.delim("../data/de_genes.tsv",
row.names = 1,
stringsAsFactors = FALSE)
vst <- readRDS("../data/vst.rds")
# Chunk 3: Heatmap
#Just consider the genes that were DE ans VST
de_genes_names <- unique(c(rownames(de_genes)))
de_genes_vst <- vst[rownames(vst) %in% de_genes_names, ]
de_genes_vst_matrix <- assay(de_genes_vst)
#Calculate the z-score
z_scores <- scale(de_genes_vst_matrix)
# Define breaks and labels for the quantile scale (putting the function, it doesn't really matter the name of the variable)
quantile_breaks <- function(z_scores, n = 10) {
breaks <- quantile(z_scores, probs = seq(0, 1, length.out = n), na.rm = TRUE)
breaks[!duplicated(breaks)]
}
breaks <- quantile_breaks(z_scores, n = 11)
# Create a heatmap using pheatmap with a specified color palette
jpeg("../doc/photos/heatmap.png", width = 1100, height = 600, res = 100)
pheatmap(t(z_scores),
#annotation_row = annotation_row_4,
cluster_rows = TRUE,
cluster_cols = TRUE,
main = "Heatmap z-score od DE genes",
breaks = breaks,
color = viridis(10),
fontsize_row = 8,
show_colnames = FALSE,
border_color = "NA",
)
dev.off()
# Chunk 1
library(pheatmap)
library(viridis)
# Chunk 2: Load the data from 02_clean.qmd
de_genes <- read.delim("../data/de_genes.tsv",
row.names = 1,
stringsAsFactors = FALSE)
vst <- readRDS("../data/vst.rds")
# Chunk 3: Heatmap
#Just consider the genes that were DE ans VST
de_genes_names <- unique(c(rownames(de_genes)))
de_genes_vst <- vst[rownames(vst) %in% de_genes_names, ]
de_genes_vst_matrix <- assay(de_genes_vst)
#Calculate the z-score
z_scores <- scale(de_genes_vst_matrix)
# Define breaks and labels for the quantile scale (putting the function, it doesn't really matter the name of the variable)
quantile_breaks <- function(z_scores, n = 10) {
breaks <- quantile(z_scores, probs = seq(0, 1, length.out = n), na.rm = TRUE)
breaks[!duplicated(breaks)]
}
breaks <- quantile_breaks(z_scores, n = 11)
# Create a heatmap using pheatmap with a specified color palette
jpeg("../doc/photos/heatmap.png", width = 1100, height = 600, res = 100)
pheatmap(t(z_scores),
#annotation_row = annotation_row_4,
cluster_rows = TRUE,
cluster_cols = TRUE,
main = "Heatmap of DE genes",
breaks = breaks,
color = viridis(10),
fontsize_row = 8,
show_colnames = FALSE,
border_color = "NA",
)
dev.off()
# Chunk 1: Load libraries
library(tidyverse)
library(ggplot2)
# Chunk 2: Set the working directory and read the data file
setwd("C:/Users/marin/OneDrive/Documentos/GitHub/s223690/R")
raw_data <- read_delim("../data/_raw/citotoxicity_genes_breast_cancer.tsv",
delim = "\t",
show_col_types = FALSE)
# Chunk 3: Rename the columns
# Sample list (The names were copied directly from the webpage)
list <- c("Genes", "GSM5574685	tumor rep1", "GSM5574686 tumor rep2", "GSM5574687 tumor rep3", "GSM5574688 tumor rep4", "GSM5574689 tumor rep5", "GSM5574690 tumor rep6", "GSM5574691 tumor rep7", "GSM5574692 tumor rep8", "GSM5574693 tumor rep9", "GSM5574694 tumor rep10", "GSM5574695 tumor rep11", "GSM5574696 tumor rep12", "GSM5574697 tumor rep13", "GSM5574698 tumor rep14", "GSM5574699 tumor rep15",  "GSM5574700 tumor rep16", "GSM5574701 tumor rep17", "GSM5574702 tumor rep18", "GSM5574703 tumor rep19", "GSM5574704 tumor rep20", "GSM5574705 tumor rep21", "GSM5574706 tumor rep22", "GSM5574707 tumor rep23", "GSM5574708 tumor rep24", "GSM5574709 tumor rep25", "GSM5574710 tumor rep26", "GSM5574711 tumor rep27", "GSM5574712 tumor rep28", "GSM5574713 tumor rep29", "GSM5574714 tumor rep30", "GSM5574715 normal rep1", "GSM5574716 normal rep2", "GSM5574717 normal rep3", "GSM5574718 normal rep4", "GSM5574719 normal rep5", "GSM5574720 normal rep6", "GSM5574721 normal rep7", "GSM5574722 normal rep8", "GSM5574723 normal rep9", "GSM5574724 normal rep10", "GSM5574725 normal rep11", "GSM5574726 normal rep12",  "GSM5574727 normal rep13", "GSM5574728 normal rep14", "GSM5574729 normal rep15", "GSM5574730 normal rep16", "GSM5574731 normal rep17", "GSM5574732 normal rep18", "GSM5574733 normal rep19", "GSM5574734 normal rep20", "GSM5574735 normal rep21", "GSM5574736 normal rep22", "GSM5574737 normal rep23", "GSM5574738 normal rep24", "GSM5574739 normal rep25", "GSM5574740 normal rep26", "GSM5574741 normal rep27", "GSM5574742 normal rep28", "GSM5574743 normal rep29", "GSM5574744 normal rep30")
# Remove words that start with "GSM" so we have the actual names
new_column_names <- gsub("\\bGSM\\w+\\s*", "", list)
new_column_names <- gsub(" ", "_", new_column_names)
# Print the cleaned list
print(new_column_names)
#Change the name of the columns with this one
clean_data <- as.data.frame(raw_data)
colnames(clean_data) <- new_column_names
# Set the first column (gene names) as rownames
rownames(clean_data) <- clean_data[, 1]
clean_data <- clean_data[, -1]
# Chunk 4: Check if there are na values in the data set
#Check if there are NaN or na values in the data set
nan_counts <- unique(colSums(is.na(clean_data)))
# Chunk 5
# Count non-zero gene expressions for each sample
non_zero_counts <- colSums(clean_data != 0)
# Sample names indicating normal or tumor
sample_names <- colnames(clean_data)
# Color vector based on sample names containing "normal" or "tumor"
colors <- ifelse(grepl("normal", sample_names), "#80CDC1", "#FDB863")
# Load ggplot2 library
library(ggplot2)
# Create bar plot
jpeg("../doc/photos/pheatmap_pathogens.png", width = 1100, height = 500, res = 100)
ggplot(data.frame(Sample = names(non_zero_counts), Count = non_zero_counts), aes(x = Sample, y = Count, fill = colors)) +
geom_bar(stat = "identity") +
xlab("Sample") +
ylab("Count of genes") +
ggtitle("Count of genes for each sample") +
scale_fill_identity() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
dev.off()
# Chunk 6: Save the clean data
# Define the path for the output .tsv file
output_file_path <- "../data/clean_data.tsv"
# Save the subset data frame to a .tsv file
write.table(clean_data, file = output_file_path,
sep = "\t",
quote = FALSE,
row.names = TRUE)
# Verify that the file has been saved
if (file.exists(output_file_path)) {
cat("Clean data has ben saved to", output_file_path, "\n")
} else {
cat("Failed to save Clean data has ben saves to", output_file_path, "\n")
}
# Chunk 1
library(tidyverse)
library(DESeq2)
library(umap)
library(ggplot2)
library(RColorBrewer)
# Chunk 2: Load the data from 02_clean.qmd
clean_data <- read.delim("../data/clean_data.tsv",
row.names = 1,
stringsAsFactors = FALSE)
# Chunk 3: Create the DESeq input (DESeq matrix)
# Set the sample names
sample_names <- colnames(clean_data)
# Set the sample conditions
sample_condition <- strsplit(sample_names, "_")
sample_condition <- sapply(sample_condition, function(x) x[1])
# Create a data frame with sample information
DESeq_matrix <- data.frame(sampleName = sample_names,
fileName = t(clean_data),
condition = sample_condition)
#Set the conditions so we can perform DESeq2 afterwards
# Convert raw_data to a matrix
count_matrix <- as.matrix(clean_data)
# Create a DESeqDataSet object. The round(count_matrix) help to have non-negative integers.
dds <- DESeqDataSetFromMatrix(countData = round(count_matrix),
colData = DESeq_matrix,
design = ~ condition)
#Get rid of the genes that have very low count
dds <- dds[ rowSums(counts(dds)) > 10, ]
# Chunk 4: VST and PCA plot
#VST for the PCA plot
dds <- estimateSizeFactors(dds)
vst <- vst(dds, blind = FALSE)
sampleDists <- dist(t(assay(vst)))
#PHeatMap with the distances
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
#jpeg("../doc/photos/distance_map.jpeg", width = 600, height = 500, res = 100)
pheatmap_distances <- pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDists,
clustering_distance_cols = sampleDists,
col = colors,
main = "Heatmap of sample-to-sample distances using the variance stabilizing transformed values")
#dev.off()
jpeg("../doc/photos/PCA.jpeg", width = 600, height = 500, res = 100)
plotPCA(vst)
dev.off()
#Add another way of performing the PCA using ggplot2
# Assuming you have already calculated the vst values and stored them in 'vst'
# Extract principal components
pca <- prcomp(t(assay(vst)))
# Create a data frame with PC scores
pca_data <- as.data.frame(pca$x[,1:2])  # Considering the first two PCs
pca_data$condition <- as.factor(DESeq_matrix$condition)  # Ensure 'condition' is a factor
# Plot using ggplot2
ggplot(pca_data, aes(x = PC1, y = PC2)) +
geom_point(aes(colour = condition),
shape = 19,
size = 2.5) +
labs(x = "PC1", y = "PC2", title = "PCA Plot using ggplot2")
# Chunk 5: Perform DESeq2 analysis of the normalised counts
# Run DESeq2 analysis
dds <- DESeq(dds)
# Chunk 1
library(tidyverse)
library(DESeq2)
library(umap)
library(ggplot2)
library(RColorBrewer)
# Chunk 2: Load the data from 02_clean.qmd
clean_data <- read.delim("../data/clean_data.tsv",
row.names = 1,
stringsAsFactors = FALSE)
# Chunk 3: Create the DESeq input (DESeq matrix)
# Set the sample names
sample_names <- colnames(clean_data)
# Set the sample conditions
sample_condition <- strsplit(sample_names, "_")
sample_condition <- sapply(sample_condition, function(x) x[1])
# Create a data frame with sample information
DESeq_matrix <- data.frame(sampleName = sample_names,
fileName = t(clean_data),
condition = sample_condition)
#Set the conditions so we can perform DESeq2 afterwards
# Convert raw_data to a matrix
count_matrix <- as.matrix(clean_data)
# Create a DESeqDataSet object. The round(count_matrix) help to have non-negative integers.
dds <- DESeqDataSetFromMatrix(countData = round(count_matrix),
colData = DESeq_matrix,
design = ~ condition)
#Get rid of the genes that have very low count
dds <- dds[ rowSums(counts(dds)) > 10, ]
# Chunk 4: VST and PCA plot
#VST for the PCA plot
dds <- estimateSizeFactors(dds)
vst <- vst(dds, blind = FALSE)
sampleDists <- dist(t(assay(vst)))
#PHeatMap with the distances
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
#jpeg("../doc/photos/distance_map.jpeg", width = 600, height = 500, res = 100)
pheatmap_distances <- pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDists,
clustering_distance_cols = sampleDists,
col = colors,
main = "Heatmap of sample-to-sample distances using the variance stabilizing transformed values")
#dev.off()
jpeg("../doc/photos/PCA.png", width = 600, height = 500, res = 100)
plotPCA(vst)
dev.off()
#Add another way of performing the PCA using ggplot2
# Assuming you have already calculated the vst values and stored them in 'vst'
# Extract principal components
pca <- prcomp(t(assay(vst)))
# Create a data frame with PC scores
pca_data <- as.data.frame(pca$x[,1:2])  # Considering the first two PCs
pca_data$condition <- as.factor(DESeq_matrix$condition)  # Ensure 'condition' is a factor
# Plot using ggplot2
ggplot(pca_data, aes(x = PC1, y = PC2)) +
geom_point(aes(colour = condition),
shape = 19,
size = 2.5) +
labs(x = "PC1", y = "PC2", title = "PCA Plot using ggplot2")
# Chunk 5: Perform DESeq2 analysis of the normalised counts
# Run DESeq2 analysis
dds <- DESeq(dds)
# Chunk 1: Load libraries
library(tidyverse)
library(ggplot2)
# Chunk 2: Set the working directory and read the data file
setwd("C:/Users/marin/OneDrive/Documentos/GitHub/s223690/R")
raw_data <- read_delim("../data/_raw/citotoxicity_genes_breast_cancer.tsv",
delim = "\t",
show_col_types = FALSE)
# Chunk 3: Rename the columns
# Sample list (The names were copied directly from the webpage)
list <- c("Genes", "GSM5574685	tumor rep1", "GSM5574686 tumor rep2", "GSM5574687 tumor rep3", "GSM5574688 tumor rep4", "GSM5574689 tumor rep5", "GSM5574690 tumor rep6", "GSM5574691 tumor rep7", "GSM5574692 tumor rep8", "GSM5574693 tumor rep9", "GSM5574694 tumor rep10", "GSM5574695 tumor rep11", "GSM5574696 tumor rep12", "GSM5574697 tumor rep13", "GSM5574698 tumor rep14", "GSM5574699 tumor rep15",  "GSM5574700 tumor rep16", "GSM5574701 tumor rep17", "GSM5574702 tumor rep18", "GSM5574703 tumor rep19", "GSM5574704 tumor rep20", "GSM5574705 tumor rep21", "GSM5574706 tumor rep22", "GSM5574707 tumor rep23", "GSM5574708 tumor rep24", "GSM5574709 tumor rep25", "GSM5574710 tumor rep26", "GSM5574711 tumor rep27", "GSM5574712 tumor rep28", "GSM5574713 tumor rep29", "GSM5574714 tumor rep30", "GSM5574715 normal rep1", "GSM5574716 normal rep2", "GSM5574717 normal rep3", "GSM5574718 normal rep4", "GSM5574719 normal rep5", "GSM5574720 normal rep6", "GSM5574721 normal rep7", "GSM5574722 normal rep8", "GSM5574723 normal rep9", "GSM5574724 normal rep10", "GSM5574725 normal rep11", "GSM5574726 normal rep12",  "GSM5574727 normal rep13", "GSM5574728 normal rep14", "GSM5574729 normal rep15", "GSM5574730 normal rep16", "GSM5574731 normal rep17", "GSM5574732 normal rep18", "GSM5574733 normal rep19", "GSM5574734 normal rep20", "GSM5574735 normal rep21", "GSM5574736 normal rep22", "GSM5574737 normal rep23", "GSM5574738 normal rep24", "GSM5574739 normal rep25", "GSM5574740 normal rep26", "GSM5574741 normal rep27", "GSM5574742 normal rep28", "GSM5574743 normal rep29", "GSM5574744 normal rep30")
# Remove words that start with "GSM" so we have the actual names
new_column_names <- gsub("\\bGSM\\w+\\s*", "", list)
new_column_names <- gsub(" ", "_", new_column_names)
# Print the cleaned list
print(new_column_names)
#Change the name of the columns with this one
clean_data <- as.data.frame(raw_data)
colnames(clean_data) <- new_column_names
# Set the first column (gene names) as rownames
rownames(clean_data) <- clean_data[, 1]
clean_data <- clean_data[, -1]
# Chunk 4: Check if there are na values in the data set
#Check if there are NaN or na values in the data set
nan_counts <- unique(colSums(is.na(clean_data)))
# Chunk 5
# Count non-zero gene expressions for each sample
non_zero_counts <- colSums(clean_data != 0)
# Sample names indicating normal or tumor
sample_names <- colnames(clean_data)
# Color vector based on sample names containing "normal" or "tumor"
colors <- ifelse(grepl("normal", sample_names), "#80CDC1", "#FDB863")
# Load ggplot2 library
library(ggplot2)
# Create bar plot
jpeg("../results/pheatmap_pathogens.png", width = 1100, height = 500, res = 100)
ggplot(data.frame(Sample = names(non_zero_counts), Count = non_zero_counts), aes(x = Sample, y = Count, fill = colors)) +
geom_bar(stat = "identity") +
xlab("Sample") +
ylab("Count of genes") +
ggtitle("Count of genes for each sample") +
scale_fill_identity() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
dev.off()
# Chunk 6: Save the clean data
# Define the path for the output .tsv file
output_file_path <- "../data/clean_data.tsv"
# Save the subset data frame to a .tsv file
write.table(clean_data, file = output_file_path,
sep = "\t",
quote = FALSE,
row.names = TRUE)
# Verify that the file has been saved
if (file.exists(output_file_path)) {
cat("Clean data has ben saved to", output_file_path, "\n")
} else {
cat("Failed to save Clean data has ben saves to", output_file_path, "\n")
}
# Chunk 1: Load libraries
library(tidyverse)
library(ggplot2)
# Chunk 2: Set the working directory and read the data file
setwd("C:/Users/marin/OneDrive/Documentos/GitHub/s223690/R")
raw_data <- read_delim("../data/_raw/citotoxicity_genes_breast_cancer.tsv",
delim = "\t",
show_col_types = FALSE)
# Chunk 3: Rename the columns
# Sample list (The names were copied directly from the webpage)
list <- c("Genes", "GSM5574685	tumor rep1", "GSM5574686 tumor rep2", "GSM5574687 tumor rep3", "GSM5574688 tumor rep4", "GSM5574689 tumor rep5", "GSM5574690 tumor rep6", "GSM5574691 tumor rep7", "GSM5574692 tumor rep8", "GSM5574693 tumor rep9", "GSM5574694 tumor rep10", "GSM5574695 tumor rep11", "GSM5574696 tumor rep12", "GSM5574697 tumor rep13", "GSM5574698 tumor rep14", "GSM5574699 tumor rep15",  "GSM5574700 tumor rep16", "GSM5574701 tumor rep17", "GSM5574702 tumor rep18", "GSM5574703 tumor rep19", "GSM5574704 tumor rep20", "GSM5574705 tumor rep21", "GSM5574706 tumor rep22", "GSM5574707 tumor rep23", "GSM5574708 tumor rep24", "GSM5574709 tumor rep25", "GSM5574710 tumor rep26", "GSM5574711 tumor rep27", "GSM5574712 tumor rep28", "GSM5574713 tumor rep29", "GSM5574714 tumor rep30", "GSM5574715 normal rep1", "GSM5574716 normal rep2", "GSM5574717 normal rep3", "GSM5574718 normal rep4", "GSM5574719 normal rep5", "GSM5574720 normal rep6", "GSM5574721 normal rep7", "GSM5574722 normal rep8", "GSM5574723 normal rep9", "GSM5574724 normal rep10", "GSM5574725 normal rep11", "GSM5574726 normal rep12",  "GSM5574727 normal rep13", "GSM5574728 normal rep14", "GSM5574729 normal rep15", "GSM5574730 normal rep16", "GSM5574731 normal rep17", "GSM5574732 normal rep18", "GSM5574733 normal rep19", "GSM5574734 normal rep20", "GSM5574735 normal rep21", "GSM5574736 normal rep22", "GSM5574737 normal rep23", "GSM5574738 normal rep24", "GSM5574739 normal rep25", "GSM5574740 normal rep26", "GSM5574741 normal rep27", "GSM5574742 normal rep28", "GSM5574743 normal rep29", "GSM5574744 normal rep30")
# Remove words that start with "GSM" so we have the actual names
new_column_names <- gsub("\\bGSM\\w+\\s*", "", list)
new_column_names <- gsub(" ", "_", new_column_names)
# Print the cleaned list
print(new_column_names)
#Change the name of the columns with this one
clean_data <- as.data.frame(raw_data)
colnames(clean_data) <- new_column_names
# Set the first column (gene names) as rownames
rownames(clean_data) <- clean_data[, 1]
clean_data <- clean_data[, -1]
# Chunk 4: Check if there are na values in the data set
#Check if there are NaN or na values in the data set
nan_counts <- unique(colSums(is.na(clean_data)))
# Chunk 5
# Count non-zero gene expressions for each sample
non_zero_counts <- colSums(clean_data != 0)
# Sample names indicating normal or tumor
sample_names <- colnames(clean_data)
# Color vector based on sample names containing "normal" or "tumor"
colors <- ifelse(grepl("normal", sample_names), "#80CDC1", "#FDB863")
# Load ggplot2 library
library(ggplot2)
# Create bar plot
jpeg("../results/barplot_gene_count.png", width = 1100, height = 500, res = 100)
ggplot(data.frame(Sample = names(non_zero_counts), Count = non_zero_counts), aes(x = Sample, y = Count, fill = colors)) +
geom_bar(stat = "identity") +
xlab("Sample") +
ylab("Count of genes") +
ggtitle("Count of genes for each sample") +
scale_fill_identity() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
dev.off()
# Chunk 6: Save the clean data
# Define the path for the output .tsv file
output_file_path <- "../data/clean_data.tsv"
# Save the subset data frame to a .tsv file
write.table(clean_data, file = output_file_path,
sep = "\t",
quote = FALSE,
row.names = TRUE)
# Verify that the file has been saved
if (file.exists(output_file_path)) {
cat("Clean data has ben saved to", output_file_path, "\n")
} else {
cat("Failed to save Clean data has ben saves to", output_file_path, "\n")
}
# Chunk 1
library(tidyverse)
library(DESeq2)
library(umap)
library(ggplot2)
library(RColorBrewer)
# Chunk 2: Load the data from 02_clean.qmd
clean_data <- read.delim("../data/clean_data.tsv",
row.names = 1,
stringsAsFactors = FALSE)
# Chunk 3: Create the DESeq input (DESeq matrix)
# Set the sample names
sample_names <- colnames(clean_data)
# Set the sample conditions
sample_condition <- strsplit(sample_names, "_")
sample_condition <- sapply(sample_condition, function(x) x[1])
# Create a data frame with sample information
DESeq_matrix <- data.frame(sampleName = sample_names,
fileName = t(clean_data),
condition = sample_condition)
#Set the conditions so we can perform DESeq2 afterwards
# Convert raw_data to a matrix
count_matrix <- as.matrix(clean_data)
# Create a DESeqDataSet object. The round(count_matrix) help to have non-negative integers.
dds <- DESeqDataSetFromMatrix(countData = round(count_matrix),
colData = DESeq_matrix,
design = ~ condition)
#Get rid of the genes that have very low count
dds <- dds[ rowSums(counts(dds)) > 10, ]
# Chunk 4: VST and PCA plot
#VST for the PCA plot
dds <- estimateSizeFactors(dds)
vst <- vst(dds, blind = FALSE)
sampleDists <- dist(t(assay(vst)))
#PHeatMap with the distances
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
#jpeg("../doc/photos/distance_map.jpeg", width = 600, height = 500, res = 100)
pheatmap_distances <- pheatmap(sampleDistMatrix,
clustering_distance_rows = sampleDists,
clustering_distance_cols = sampleDists,
col = colors,
main = "Heatmap of sample-to-sample distances using the variance stabilizing transformed values")
#dev.off()
jpeg("../results/PCA.png", width = 600, height = 500, res = 100)
plotPCA(vst)
dev.off()
#Add another way of performing the PCA using ggplot2
# Assuming you have already calculated the vst values and stored them in 'vst'
# Extract principal components
pca <- prcomp(t(assay(vst)))
# Create a data frame with PC scores
pca_data <- as.data.frame(pca$x[,1:2])  # Considering the first two PCs
pca_data$condition <- as.factor(DESeq_matrix$condition)  # Ensure 'condition' is a factor
# Plot using ggplot2
ggplot(pca_data, aes(x = PC1, y = PC2)) +
geom_point(aes(colour = condition),
shape = 19,
size = 2.5) +
labs(x = "PC1", y = "PC2", title = "PCA Plot using ggplot2")
# Chunk 5: Perform DESeq2 analysis of the normalised counts
# Run DESeq2 analysis
dds <- DESeq(dds)
# Chunk 1
library(pheatmap)
library(viridis)
# Chunk 2: Load the data from 02_clean.qmd
de_genes <- read.delim("../data/de_genes.tsv",
row.names = 1,
stringsAsFactors = FALSE)
vst <- readRDS("../data/vst.rds")
# Chunk 3: Heatmap
#Just consider the genes that were DE ans VST
de_genes_names <- unique(c(rownames(de_genes)))
de_genes_vst <- vst[rownames(vst) %in% de_genes_names, ]
de_genes_vst_matrix <- assay(de_genes_vst)
#Calculate the z-score
z_scores <- scale(de_genes_vst_matrix)
# Define breaks and labels for the quantile scale (putting the function, it doesn't really matter the name of the variable)
quantile_breaks <- function(z_scores, n = 10) {
breaks <- quantile(z_scores, probs = seq(0, 1, length.out = n), na.rm = TRUE)
breaks[!duplicated(breaks)]
}
breaks <- quantile_breaks(z_scores, n = 11)
# Create a heatmap using pheatmap with a specified color palette
jpeg("../results/heatmap.png", width = 1100, height = 600, res = 100)
pheatmap(t(z_scores),
#annotation_row = annotation_row_4,
cluster_rows = TRUE,
cluster_cols = TRUE,
main = "Heatmap of DE genes",
breaks = breaks,
color = viridis(10),
fontsize_row = 8,
show_colnames = FALSE,
border_color = "NA",
)
dev.off()
# Chunk 1
library(tidyverse)
library(quarto)
library(EnhancedVolcano)
# Chunk 2: Load the data from 02_clean.qmd
res <- read.delim("../data/DESeq2_results.tsv",
row.names = 1,
stringsAsFactors = FALSE)
# Chunk 3: Volcano plot of DE genes
volcano_plot_data <- as.data.frame(res)
#See what are the maximum and minimum values for the plot
max_log2_volcano_plot <- max(volcano_plot_data$log2FoldChange)
min_log2_volcano_plot <- min(volcano_plot_data$log2FoldChange)
max_pvalue_volcano_plot <- max(-log10(volcano_plot_data$pvalue))
min_pvalue_volcano_plot <- min(-log10(volcano_plot_data$pvalue))
#Create the volcano plot (log2Fold change = 3, pvalue < 0.1)
jpeg("../results/volcano_plot.png", width = 700, height = 500, res = 100)
EnhancedVolcano(volcano_plot_data,
lab = row.names(volcano_plot_data),
labSize = 4,
x = "log2FoldChange",
xlim = c(min_log2_volcano_plot, max_log2_volcano_plot),
y = "padj",
ylim = c(min_pvalue_volcano_plot, max_pvalue_volcano_plot),
pCutoff = 0.1,
FCcutoff = 3,
axisLabSize = 12,
caption = NULL,
subtitle = NULL,
legendPosition = "none",
title = "Volcano plot"
)
#dev.off()
