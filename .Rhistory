#ylim(y_limits)
# Chunk 4
library(ggplot2)
# Calculate log-ratios with all the combinations posible
ratio_x1_x2 <- matrix[1, ]/matrix[2, ]
ratio_x1_x3 <- matrix[1, ]/matrix[3, ]
ratio_x2_x3 <- ratio_x1_x2 / ratio_x1_x3
#Create a data frame to introduce into the ggplot function
ratios <- data.frame(ratio_x1_x2, ratio_x1_x3)
#Set the parameters for the line of the third ratio: interception and slope
#intercept <- mean(log_ratio_x1_x3 - log_ratio_x1_x2 * log_ratio_x2_x3)
#slope <- mean(log_ratio_x2_x3)
#x_range <- range(c(log_ratio_x1_x3[, 1], log_ratio_x1_x2[, 1], log_ratio_x2_x3[, 1]))
#y_range <- range(c(log_ratio_x1_x3[, 2], log_ratio_x1_x2[, 2], log_ratio_x2_x3[, 2]))
# Set limits for x and y axes
#x_limits <- c(0, 2)  # Replace with your actual minimum and maximum values for x
#y_limits <- c(0, 2.7)  # Replace with your actual minimum and maximum values for y
# Create scatter plot
ggplot(ratios, aes (x = ratio_x1_x2, y = ratio_x1_x3)) +
geom_point(col = "#287D8EFF",
size = 2.5) +
labs(x = "Ratio s1/s2", y = "Ratio s1/s3", title = "Ratio Scatter Plot")
#xlim(x_limits)) +
#ylim(y_limits)
# Chunk 5
library(ggplot2)
avocado <- c(8.64, 1.96, 14.41)
beans <- c(14.50, 5.22, 0.60)
carrot <- c(9.58, 0.93, 0.24)
celery <- c(2.97, 0.69, 0.17)
chanterelle <- c(6.86, 1.49, 0.53)
chickpea <- c(22.53, 7.05, 2.77)
corn <- c(19.02, 3.22, 1.18)
kale <- c(4.42, 2.92, 1.49)
potato <- c(17.49, 2.05, 0.09)
yam <- c(27.88, 1.53, 0.17)
matrix_2 <- rbind(avocado, beans, carrot, celery, chanterelle, chickpea, corn, kale, potato, yam)
colnames(matrix_2) <- c("carbohydrates", "protein", "fat")
# Calculate log-ratios with all the combinations posible
ratio_carbohydrates_protein <- log(matrix_2[, 1]/matrix_2[, 2])
ratio_carbohydrates_fat <- log(matrix_2[, 1]/matrix_2[, 3])
ratio_protein_fat <- ratio_carbohydrates_fat - ratio_carbohydrates_protein
#Create a data frame to introduce into the ggplot function
ratios_2 <- data.frame(ratio_carbohydrates_protein, ratio_carbohydrates_fat)
#Set the parameters for the line of the third ratio: interception and slope
#intercept <- mean(log_ratio_x1_x3 - log_ratio_x1_x2 * log_ratio_x2_x3)
#slope <- mean(log_ratio_x2_x3)
#x_range <- range(c(log_ratio_x1_x3[, 1], log_ratio_x1_x2[, 1], log_ratio_x2_x3[, 1]))
#y_range <- range(c(log_ratio_x1_x3[, 2], log_ratio_x1_x2[, 2], log_ratio_x2_x3[, 2]))
# Set limits for x and y axes
x_limits <- c(0, 2)  # Replace with your actual minimum and maximum values for x
y_limits <- c(0, 2.7)  # Replace with your actual minimum and maximum values for y
# Create scatter plot
ggplot(ratios_2, aes(x = ratio_carbohydrates_protein, y = ratio_carbohydrates_fat)) +
geom_point(col = "#287D8EFF", size = 2.5) +
labs(x = "carbohydrate / protein", y = "carbohydrate / fat") +
xlim(x_limits) +
ylim(y_limits) +
geom_abline(intercept = 5,
slope = -1,
color = "red",
linetype = "dashed") +
xlim(c(-1, 6)) +
ylim(c(-1, 6))
# Chunk 6: Exercise 5.3
#Plot a ternary plot
library(Ternary)
library(RColorBrewer)
#Plot with an empty structure
TernaryPlot(main = "Ternary plot",
alab = "X1",
blab = "X2",
clab = "X3",
lab.cex = 0.8, #Set the size of the axis names
axis.cex = 0.5, #Size of the axis number
grid.lines = 10, #Set how many numbers you want to see for axis
grid.minor.lines = 0) #Set the grid every 10% only, not lines in between
# Plot the points
TernaryPoints(matrix,
pch = 19, # Plotting symbol (19 = filled circle)
col = "#287D8EFF")
# Chunk 7: Exercise 5.4
#Build a basis for the data, ILR transform the data, and plot them in the cartesian coordinate system
#CALCULATE THE BASIS AND NORMALISE IT
#Define the initial matrix (basis)
basis_5_4 <- matrix(c(1, 1, -1, 1, -1, 0), ncol = 3, byrow = TRUE)
# Initialize vectors to store r and s values for each row
r_values <- numeric(nrow(basis_5_4))
s_values <- numeric(nrow(basis_5_4))
# Calculate r and s values for each row
for (i in 1:nrow(basis_5_4)) {
r_values[i] <- sum(basis_5_4[i, ] == 1)
s_values[i] <- sum(basis_5_4[i, ] == -1)
}
# Normalise the given matrix with a loop for each row
for (i in 1:nrow(basis_5_4)) {
for (j in 1:ncol(basis_5_4)) {
if (basis_5_4[i, j] == 1) {
basis_5_4[i, j] <- 1 / r_values[i] * sqrt((r_values[i] * s_values[i]) / (r_values[i] + s_values[i]))
} else if (basis_5_4[i, j] == -1) {
basis_5_4[i, j] <- -1 / s_values[i] * sqrt((r_values[i] * s_values[i]) / (r_values[i] + s_values[i]))
} else if (basis_5_4[i, j] == 0) {
basis_5_4[i, j] <- 0
}
}
}
#CALCULATE CLR
#Calculate the gm and clr (apply function is used to go through each one of the rows and then apply the equation). Each vector will have their own clr value.
gm_5_4 <- apply(matrix, 1, function(row) prod(row)^(1/3))
clr_5_4 <- t(apply(matrix, 1, function(row) log(row / exp(mean(log(row))))))
clr_5_4 <- round(clr_5_4, 2)
clr_5_4 <- t(clr_5_4)
#Verify that the sum of the compositions is 0.
verify_clr_5_4 <- apply(clr_5_4, 1, sum)
#Check the dimensions of both matrix (results)
# Should be [number of compositions] x [number of parts]
print(dim(clr_5_4))
# Should be [number of parts] x [number of binary partition bases]
print(dim(basis_5_4))
#Calculate the ilr_1
ilr_5_4 <- clr_5_4 %*% t(basis_5_4)
ilr_5_4 <- round(ilr_5_4, 2)
#Plot the points
ggplot() +
geom_point(aes(x = ilr_5_4[,1], y = ilr_5_4[,2],),
color = 'purple', size = 2) +
labs(title = "ILR in the cartesian coordinate system") +
xlab("X coordinates") +
ylab("Y coordinates")
# Chunk 8: Exercise 5.5
#Perturb the data by s = [0.1, 0.1, 0.8] and plot the initial and the perturbed data set in a ternary diagram and in ILR coordinates. In each case, join each pair of samples (unperturbed and perturbed) by a line segment. Observe the effect of perturbation.
s = c(0.1, 0.1, 0.8)
perturbed_matrix = matrix * s
#CALCULATE THE BASIS AND NORMALISE IT
#Define the initial matrix (basis)
basis_5_5 <- matrix(c(1, 1, -1, 1, -1, 0), ncol = 3, byrow = TRUE)
# Initialize vectors to store r and s values for each row
r_values <- numeric(nrow(basis_5_5))
s_values <- numeric(nrow(basis_5_5))
# Calculate r and s values for each row
for (i in 1:nrow(basis_5_5)) {
r_values[i] <- sum(basis_5_5[i, ] == 1)
s_values[i] <- sum(basis_5_5[i, ] == -1)
}
# Normalise the given matrix with a loop for each row
for (i in 1:nrow(basis_5_5)) {
for (j in 1:ncol(basis_5_5)) {
if (basis_5_5[i, j] == 1) {
basis_5_5[i, j] <- 1 / r_values[i] * sqrt((r_values[i] * s_values[i]) / (r_values[i] + s_values[i]))
} else if (basis_5_5[i, j] == -1) {
basis_5_5[i, j] <- -1 / s_values[i] * sqrt((r_values[i] * s_values[i]) / (r_values[i] + s_values[i]))
} else if (basis_5_5[i, j] == 0) {
basis_5_5[i, j] <- 0
}
}
}
#CALCULATE CLR
#Calculate the gm and clr (apply function is used to go through each one of the rows and then apply the equation). Each vector will have their own clr value.
gm_5_5 <- apply(perturbed_matrix, 1, function(row) prod(row)^(1/3))
clr_5_5 <- t(apply(perturbed_matrix, 1, function(row) log(row / exp(mean(log(row))))))
clr_5_5 <- round(clr_5_5, 2)
clr_5_5 <- t(clr_5_5)
#Verify that the sum of the compositions is 0.
verify_clr_5_5 <- apply(clr_5_5, 1, sum)
#Check the dimensions of both matrix (results)
# Should be [number of compositions] x [number of parts]
print(dim(clr_5_5))
# Should be [number of parts] x [number of binary partition bases]
print(dim(basis_5_5))
#Calculate the ilr_1
ilr_5_5 <- clr_5_5 %*% t(basis_5_5)
ilr_5_5 <- round(ilr_5_5, 2)
#Plot the points
ggplot() +
geom_point(aes(x = ilr_5_4[,1], y = ilr_5_4[,2],),
color = 'purple', size = 2) +
geom_point(aes(x = ilr_5_5[,1], y = ilr_5_5[,2],),
color = 'salmon', size = 2) +
labs(title = "ILR in the cartesian coordinate system") +
xlab("X coordinates") +
ylab("Y coordinates")
#The fact that you are perturbing the matrix doesn't affect the ILR.
# Chunk 9: Exercise 3.6
#Apply powering with alpha ranging from -8 to +8 in steps of 1 to the composition t = [0.7, 0.5, 0.8] and plot the resulting set of compositions in a ternary diagram and in ILR coordinates. Observe the effect of powering.
#Define the t composition
t <- c(0.7, 0.5, 0.8)
#Define the sequence of alpha
alphas <- seq(-8, 8, by = 1)
#Definition of the function compositions that will give you the powering
compositions <- function(t, alpha) {
return(t^alpha)
}
#Use the function with t and all the alphas of the sequence to create a matrix
compositions_matrix <- sapply(alphas, function(alpha) compositions(t, alpha))
#Change the name of the matrix
rownames(compositions_matrix) <- c("x1", "x2", "x3")
#CREATE THE TERNARY DIAGRAM
#Adjust the size of the plot using the mar, that are the margain
par(mar = c(3, 3, 1, 1))  # Adjust top, right, bottom, and left margins
#Plot with an empty structure
TernaryPlot(main = "Ternary plot",
alab = "X1",
blab = "X2",
clab = "X3",
lab.cex = 0.8, #Set the size of the axis names
axis.cex = 0.5, #Size of the axis number
grid.lines = 10, #Set how many numbers you want to see for axis
grid.minor.lines = 0) #Set the grid every 10% only, not lines in between
# Plot the points
TernaryPoints(compositions_matrix,
pch = 19, # Plotting symbol (19 = filled circle)
col = "#287D8EFF")
#REPRESENT THE RESULTING COMPOSITION INTO THE ILR COORDINATES
#CALCULATE THE BASIS AND NORMALISE IT
#Define the initial matrix (basis)
basis_5_6 <- matrix(c(1, 1, -1, 1, -1, 0), ncol = 3, byrow = TRUE)
# Initialize vectors to store r and s values for each row
r_values <- numeric(nrow(basis_5_6))
s_values <- numeric(nrow(basis_5_6))
# Calculate r and s values for each row
for (i in 1:nrow(basis_5_6)) {
r_values[i] <- sum(basis_5_6[i, ] == 1)
s_values[i] <- sum(basis_5_6[i, ] == -1)
}
# Normalise the given matrix with a loop for each row
for (i in 1:nrow(basis_5_6)) {
for (j in 1:ncol(basis_5_6)) {
if (basis_5_6[i, j] == 1) {
basis_5_6[i, j] <- 1 / r_values[i] * sqrt((r_values[i] * s_values[i]) / (r_values[i] + s_values[i]))
} else if (basis_5_6[i, j] == -1) {
basis_5_6[i, j] <- -1 / s_values[i] * sqrt((r_values[i] * s_values[i]) / (r_values[i] + s_values[i]))
} else if (basis_5_6[i, j] == 0) {
basis_5_6[i, j] <- 0
}
}
}
#CALCULATE CLR
#Calculate the gm and clr (apply function is used to go through each one of the rows and then apply the equation). Each vector will have their own clr value.
gm_5_6 <- apply(compositions_matrix, 1, function(row) prod(row)^(1/3))
clr_5_6 <- t(apply(compositions_matrix, 1, function(row) log(row / exp(mean(log(row))))))
clr_5_6 <- round(clr_5_6, 2)
clr_5_6 <- t(clr_5_6)
#Verify that the sum of the compositions is 0.
verify_clr_5_6 <- apply(clr_5_6, 1, sum)
#Check the dimensions of both matrix (results)
# Should be [number of compositions] x [number of parts]
print(dim(clr_5_6))
# Should be [number of parts] x [number of binary partition bases]
print(dim(basis_5_6))
#Calculate the ilr_1
ilr_5_6 <- clr_5_6 %*% t(basis_5_6)
ilr_5_6 <- round(ilr_5_6, 2)
#Plot the points
ggplot() +
geom_point(aes(x = ilr_5_6[,1], y = ilr_5_6[,2],),
color = 'purple', size = 2) +
labs(title = "ILR in the cartesian coordinate system") +
xlab("X coordinates") +
ylab("Y coordinates")
library(ggplot2)
# Calculate log-ratios with all the combinations posible
ratio_x1_x2 <- matrix[1, ]/matrix[2, ]
ratio_x1_x3 <- matrix[1, ]/matrix[3, ]
ratio_x2_x3 <- ratio_x1_x2 / ratio_x1_x3
#Create a data frame to introduce into the ggplot function
ratios <- data.frame(ratio_x1_x2, ratio_x1_x3)
#Set the parameters for the line of the third ratio: interception and slope
#intercept <- mean(log_ratio_x1_x3 - log_ratio_x1_x2 * log_ratio_x2_x3)
#slope <- mean(log_ratio_x2_x3)
#x_range <- range(c(log_ratio_x1_x3[, 1], log_ratio_x1_x2[, 1], log_ratio_x2_x3[, 1]))
#y_range <- range(c(log_ratio_x1_x3[, 2], log_ratio_x1_x2[, 2], log_ratio_x2_x3[, 2]))
# Set limits for x and y axes
#x_limits <- c(0, 2)  # Replace with your actual minimum and maximum values for x
#y_limits <- c(0, 2.7)  # Replace with your actual minimum and maximum values for y
# Create scatter plot
ggplot(ratios, aes (x = ratio_x1_x2, y = ratio_x1_x3)) +
geom_point(col = "#287D8EFF",
size = 2.5) +
labs(x = "Ratio s1/s2", y = "Ratio s1/s3", title = "Ratio Scatter Plot")
#xlim(x_limits)) +
#ylim(y_limits)
library(ggplot2)
# Calculate log-ratios with all the combinations posible
log_ratio_x1_x2 <- log(matrix[1, ]/matrix[2, ])
log_ratio_x1_x3 <- log(matrix[1, ]/matrix[3, ])
log_ratio_x2_x3 <- log_ratio_x1_x2 - log_ratio_x1_x3
#Create a data frame to introduce into the ggplot function
log_ratios <- data.frame(log_ratio_x1_x2, log_ratio_x1_x3)
#Set the parameters for the line of the third ratio: interception and slope
intercept <- mean(log_ratio_x1_x3 - log_ratio_x1_x2 * log_ratio_x2_x3)
slope <- mean(log_ratio_x2_x3)
#x_range <- range(c(log_ratio_x1_x3[, 1], log_ratio_x1_x2[, 1], log_ratio_x2_x3[, 1]))
#y_range <- range(c(log_ratio_x1_x3[, 2], log_ratio_x1_x2[, 2], log_ratio_x2_x3[, 2]))
# Set limits for x and y axes
x_limits <- c(0, 2)  # Replace with your actual minimum and maximum values for x
y_limits <- c(0, 2.7)  # Replace with your actual minimum and maximum values for y
# Create scatter plot
ggplot(log_ratios, aes (x = log_ratio_x1_x2, y = log_ratio_x1_x3)) +
geom_point(col = "#287D8EFF",
size = 2.5) +
geom_abline(intercept = intercept, slope = -1, color = "red", linetype = "dashed") +
labs(x = "Log Ratio s1/s2", y = "Log Ratio s1/s3", title = "Log-Ratio Scatter Plot")
#xlim(x_limits)) +
#ylim(y_limits)
library(ggplot2)
# Calculate log-ratios with all the combinations posible
log_ratio_x1_x2 <- log(matrix[1, ]/matrix[2, ])
log_ratio_x1_x3 <- log(matrix[1, ]/matrix[3, ])
log_ratio_x2_x3 <- log_ratio_x1_x2 - log_ratio_x1_x3
#Create a data frame to introduce into the ggplot function
log_ratios <- data.frame(log_ratio_x1_x2, log_ratio_x1_x3)
# Create scatter plot
ggplot(log_ratios, aes (x = log_ratio_x1_x2, y = log_ratio_x1_x3)) +
geom_point(col = "#287D8EFF",
size = 2.5) +
geom_abline(intercept = 3, slope = -1, color = "red", linetype = "dashed") +
labs(x = "Log Ratio s1/s2", y = "Log Ratio s1/s3", title = "Log-Ratio Scatter Plot")
# Create scatter plot
ggplot(log_ratios, aes (x = log_ratio_x1_x2, y = log_ratio_x1_x3)) +
geom_point(col = "#287D8EFF",
size = 2.5) +
geom_abline(intercept = 3, slope = -1, color = "red", linetype = "dashed") +
labs(x = "Log Ratio s1/s2", y = "Log Ratio s1/s3", title = "Log-Ratio Scatter Plot")
```{r}
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(echo = TRUE)
#Create a bar plot and a stacked bar plot with the data
library(viridis)
#Define data
s1 = c(79.07, 12.83, 8.10)
s2 = c(31.74, 56.69, 11.57)
s3 = c(18.61, 72.05, 9.34)
s4 = c(49.51, 15.11, 35.38)
s5 = c(29.22, 52.36, 18.42)
#Put together the vectors to create a matrix
matrix = cbind(s1, s2, s3, s4, s5)
#Change the rownames to the ones I want
rownames(matrix) = c("x1", "x2", "x3")
#Bar plot
barplot(matrix,
main = "Bar plot",
col = inferno(3),
beside = T)
#Stacked barplot
barplot(matrix,
main = "Stacked bar plot",
col = inferno(3))
library(ggplot2)
# Calculate log-ratios with all the combinations posible
log_ratio_x1_x2 <- log(matrix[1, ]/matrix[2, ])
log_ratio_x1_x3 <- log(matrix[1, ]/matrix[3, ])
log_ratio_x2_x3 <- log_ratio_x1_x2 - log_ratio_x1_x3
#Create a data frame to introduce into the ggplot function
log_ratios <- data.frame(log_ratio_x1_x2, log_ratio_x1_x3)
# Create scatter plot
ggplot(log_ratios, aes (x = log_ratio_x1_x2, y = log_ratio_x1_x3)) +
geom_point(col = "#287D8EFF",
size = 2.5) +
geom_abline(intercept = 3, slope = -1, color = "red", linetype = "dashed") +
labs(x = "Log Ratio s1/s2", y = "Log Ratio s1/s3", title = "Log-Ratio Scatter Plot")
#Stacked barplot
barplot(matrix,
main = "Stacked bar plot",
col = inferno(3))
#Bar plot
barplot(matrix,
main = "Bar plot",
col = inferno(3),
beside = T)
# Chunk 1
library("tidyverse")
library("quarto")
# Chunk 2
dir.create("data/_raw", recursive = TRUE)
dir.create("results")
dir.create("doc")
# Chunk 3
#| warning: false
#| message: false
# Run 01_load file and save it as .html in the results folder
#quarto::quarto_render("01_load.qmd")
#file.rename("01_load.html", "../results/01_load.html")
# Run 02_clean file and save it as .html in the results folder
#quarto::quarto_render("02_clean.qmd")
#file.rename("02_clean.html", "../results/02_clean.html")
# Run 03_describe file and save it as .html in the results folder
#quarto::quarto_render("03_describe.qmd")
#file.rename("03_describe.html", "../results/03_describe.html")
# Run 04_augment file and save it as .html in the results folder
#quarto::quarto_render("04_augment.qmd")
#file.rename("04_augment.html", "../results/04_augment.html")
# Run 05_analysis_1 file and save it as .html in the results folder
#quarto::quarto_render("05_analysis_1.qmd")
#file.rename("05_analysis_1.html", "../results/05_analysis_1.html")
# Run 06_analysis_2 file and save it as .html in the results folder
#quarto::quarto_render("06_analysis_2.qmd")
#file.rename("06_analysis_2.html", "../results/06_analysis_2.html")
# Run 07_analysis_3 file and save it as .html in the results folder
#quarto::quarto_render("07_analysis_3.qmd")
#file.rename("07_analysis_3.html", "../results/07_analysis_3.html")
# Run Presentation file and save it as .html in the results folder
#quarto::quarto_render("../doc/presentation.qmd")
getwd()
setwd(C:/Users/marin/OneDrive/Documentos/GitHub/s223690)
setwd(/Users/marin/OneDrive/Documentos/GitHub/s223690)
setwd(Users/marin/OneDrive/Documentos/GitHub/s223690)
setwd(C:\Users\marin\OneDrive\Documentos\GitHub\s223690)
setwd(\Users\marin\OneDrive\Documentos\GitHub\s223690)
setwd(Users\marin\OneDrive\Documentos\GitHub\s223690)
setwd("C:/Users/marin/OneDrive/Documentos/GitHub/s223690")
dir.create("doc")
# Chunk 1
library("tidyverse")
library("quarto")
# Chunk 2
dir.create("data/_raw", recursive = TRUE)
dir.create("results")
dir.create("doc")
# Chunk 3
#| warning: false
#| message: false
# Run 01_load file and save it as .html in the results folder
#quarto::quarto_render("01_load.qmd")
#file.rename("01_load.html", "../results/01_load.html")
# Run 02_clean file and save it as .html in the results folder
#quarto::quarto_render("02_clean.qmd")
#file.rename("02_clean.html", "../results/02_clean.html")
# Run 03_describe file and save it as .html in the results folder
#quarto::quarto_render("03_describe.qmd")
#file.rename("03_describe.html", "../results/03_describe.html")
# Run 04_augment file and save it as .html in the results folder
#quarto::quarto_render("04_augment.qmd")
#file.rename("04_augment.html", "../results/04_augment.html")
# Run 05_analysis_1 file and save it as .html in the results folder
#quarto::quarto_render("05_analysis_1.qmd")
#file.rename("05_analysis_1.html", "../results/05_analysis_1.html")
# Run 06_analysis_2 file and save it as .html in the results folder
#quarto::quarto_render("06_analysis_2.qmd")
#file.rename("06_analysis_2.html", "../results/06_analysis_2.html")
# Run 07_analysis_3 file and save it as .html in the results folder
#quarto::quarto_render("07_analysis_3.qmd")
#file.rename("07_analysis_3.html", "../results/07_analysis_3.html")
# Run Presentation file and save it as .html in the results folder
#quarto::quarto_render("../doc/presentation.qmd")
# Chunk 1
library("tidyverse")
library("quarto")
# Chunk 2
dir.create("data/_raw", recursive = TRUE)
dir.create("results")
dir.create("doc")
# Chunk 3
#| warning: false
#| message: false
# Run 01_load file and save it as .html in the results folder
#quarto::quarto_render("01_load.qmd")
#file.rename("01_load.html", "../results/01_load.html")
# Run 02_clean file and save it as .html in the results folder
#quarto::quarto_render("02_clean.qmd")
#file.rename("02_clean.html", "../results/02_clean.html")
# Run 03_describe file and save it as .html in the results folder
#quarto::quarto_render("03_describe.qmd")
#file.rename("03_describe.html", "../results/03_describe.html")
# Run 04_augment file and save it as .html in the results folder
#quarto::quarto_render("04_augment.qmd")
#file.rename("04_augment.html", "../results/04_augment.html")
# Run 05_analysis_1 file and save it as .html in the results folder
#quarto::quarto_render("05_analysis_1.qmd")
#file.rename("05_analysis_1.html", "../results/05_analysis_1.html")
# Run 06_analysis_2 file and save it as .html in the results folder
#quarto::quarto_render("06_analysis_2.qmd")
#file.rename("06_analysis_2.html", "../results/06_analysis_2.html")
# Run 07_analysis_3 file and save it as .html in the results folder
#quarto::quarto_render("07_analysis_3.qmd")
#file.rename("07_analysis_3.html", "../results/07_analysis_3.html")
# Run Presentation file and save it as .html in the results folder
#quarto::quarto_render("../doc/presentation.qmd")
# Chunk 1
library("tidyverse")
library("quarto")
# Chunk 2
dir.create("data/_raw", recursive = TRUE)
dir.create("results")
dir.create("doc")
dir.create("R")
# Chunk 3
#| warning: false
#| message: false
# Run 01_load file and save it as .html in the results folder
#quarto::quarto_render("01_load.qmd")
#file.rename("01_load.html", "../results/01_load.html")
# Run 02_clean file and save it as .html in the results folder
#quarto::quarto_render("02_clean.qmd")
#file.rename("02_clean.html", "../results/02_clean.html")
# Run 03_describe file and save it as .html in the results folder
#quarto::quarto_render("03_describe.qmd")
#file.rename("03_describe.html", "../results/03_describe.html")
# Run 04_augment file and save it as .html in the results folder
#quarto::quarto_render("04_augment.qmd")
#file.rename("04_augment.html", "../results/04_augment.html")
# Run 05_analysis_1 file and save it as .html in the results folder
#quarto::quarto_render("05_analysis_1.qmd")
#file.rename("05_analysis_1.html", "../results/05_analysis_1.html")
# Run 06_analysis_2 file and save it as .html in the results folder
#quarto::quarto_render("06_analysis_2.qmd")
#file.rename("06_analysis_2.html", "../results/06_analysis_2.html")
# Run 07_analysis_3 file and save it as .html in the results folder
#quarto::quarto_render("07_analysis_3.qmd")
#file.rename("07_analysis_3.html", "../results/07_analysis_3.html")
# Run Presentation file and save it as .html in the results folder
#quarto::quarto_render("../doc/presentation.qmd")
